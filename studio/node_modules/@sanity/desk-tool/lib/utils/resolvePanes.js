"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolvePanes = resolvePanes;
exports.LOADING = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _shallowEquals = _interopRequireDefault(require("shallow-equals"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _isSubscribable = _interopRequireDefault(require("./isSubscribable"));

var _validateStructure = _interopRequireDefault(require("./validateStructure"));

var _serializeStructure = _interopRequireDefault(require("./serializeStructure"));

var _generateHelpUrl = _interopRequireDefault(require("@sanity/generate-help-url"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LOADING = Symbol('LOADING');
exports.LOADING = LOADING;

function resolvePanes(structure, paneSegments, prevStructure, fromIndex) {
  var waitStructure = (0, _isSubscribable.default)(structure) ? (0, _rxjs.from)(structure) : (0, _rxjs.of)(structure);
  return waitStructure.pipe((0, _operators.switchMap)(struct => resolveForStructure(struct, paneSegments, prevStructure, fromIndex)));
}

function getInitialPanes(prevStructure, numPanes, fromIndex) {
  var allLoading = new Array(numPanes).fill(LOADING);

  if (!prevStructure) {
    return allLoading;
  }

  var remains = prevStructure.slice(0, fromIndex);
  return remains.concat(allLoading.slice(fromIndex));
}

function resolveForStructure(structure, paneSegments, prevStructure, fromIndex) {
  return _rxjs.Observable.create(subscriber => {
    try {
      (0, _validateStructure.default)(structure);
    } catch (err) {
      subscriber.error(err);
      return unsubscribe;
    }

    var paneIds = [structure.id].concat(paneSegments.map(seg => seg.id)).filter(Boolean);
    var panes = getInitialPanes(prevStructure, paneIds.length, fromIndex + 1);
    var subscriptions = []; // Start with all-loading (or previous structure) state

    subscriber.next(panes); // Start resolving pane-by-pane

    resolve(Math.max(0, panes.indexOf(LOADING)));
    return unsubscribe;

    function resolve(index) {
      if (index > paneIds.length - 1) {
        return;
      }

      var parameters = (0, _get2.default)(paneSegments, [index - 1, 'params']);
      var id = paneIds[index];
      var parent = panes[index - 1];
      var context = {
        parent,
        index,
        path: paneIds.slice(0, index + 1),
        parameters
      };

      if (index === 0) {
        subscribeForUpdates(structure, index, context);
        return;
      }

      if (!parent || !parent.child) {
        subscriber.complete();
        return;
      }

      subscribeForUpdates(parent.child, index, context, [id, context]);
    }

    function withUrlParameters(result, urlParameters) {
      return urlParameters ? _objectSpread({}, result, {
        urlParameters
      }) : result;
    }

    function subscribeForUpdates(pane, index, context, resolverArgs) {
      var parameters = context.parameters;
      var source = (0, _serializeStructure.default)(pane, context, resolverArgs);
      subscriptions.push(source.subscribe(result => emit(withUrlParameters(result, parameters), index), error => subscriber.error(error)));
    }

    function emit(pane, index) {
      if (typeof pane === 'undefined') {
        // eslint-disable-next-line no-console
        console.warn('Pane at index %d returned no child - see %s', index, (0, _generateHelpUrl.default)('structure-item-returned-no-child'));
      }

      if (replacePane(pane, index)) {
        subscriber.next(panes); // eslint-disable-line callback-return
      }

      resolve(index + 1);
    }

    function replacePane(pane, index) {
      if (panes[index] === pane || (0, _shallowEquals.default)(panes[index], pane)) {
        return undefined;
      }

      panes = panes.slice();
      return pane ? panes.splice(index, 1, pane) : panes.splice(index);
    }

    function unsubscribe() {
      while (subscriptions.length) {
        subscriptions.pop().unsubscribe();
      }
    }
  });
}